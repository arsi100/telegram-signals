import os
import requests
import logging
import re # For Markdown escaping
import html # For HTML escaping
from . import config

# Configure logging - Handled by basicConfig in technical_analysis.py or main entry point
logger = logging.getLogger(__name__)

def html_escape(text: str) -> str:
    """A simple wrapper for html.escape."""
    if not text:
        return ""
    return html.escape(str(text))

def _format_signal_message(signal: dict) -> str:
    """
    Formats a signal dictionary into a Telegram message string.
    NOTE: Does NOT escape markdown characters.
    """
    # ---------------------------------------------------------------------
    # Our micro-scalp engine emits two distinct payload shapes:
    #  1. Trade *signals* ‚Äì generated by logic_engine.py
    #        {
    #          "symbol": "SOLUSDT",
    #          "side":   "BUY" | "SELL",
    #          "entry_price": float,
    #          "take_profit": float,
    #          "stop_loss":  float,
    #          ...
    #        }
    #  2. Trade *results* ‚Äì produced by position_tracker.py
    #        {
    #          "symbol":   "SOLUSDT",
    #          "side":     "BUY" | "SELL",
    #          "entry":    float,
    #          "exit":     float,
    #          "pnl_pct":  float,
    #          "result":   "WIN" | "LOSS",
    #          ...
    #        }
    # ---------------------------------------------------------------------

    # --- Common fields ----------------------------------------------------
    symbol = signal.get("symbol", "N/A")

    # Determine if this is an *open* signal or a *result/exit* ----------------
    is_result = "exit" in signal or signal.get("type", "").upper() == "EXIT"

    # ---------------------------------------------------------------------
    # FORMATTER FOR TRADE RESULTS (more polished)
    # ---------------------------------------------------------------------
    if is_result:
        # FALLBACKS
        exit_price = signal.get("exit") or signal.get("price") or 0.0
        pnl_percent = signal.get("pnl_pct") or signal.get("pnl_percent")
        side_raw = signal.get("side", "").upper()
        pos_type = "LONG" if side_raw == "BUY" else ("SHORT" if side_raw == "SELL" else side_raw)
        reason = html_escape(signal.get("reason", "manual close"))

        if pnl_percent is None:
            emoji = "üö™"
            pnl_str = ""
        else:
            emoji = "‚úÖ" if pnl_percent > 0 else "‚ùå"
            pnl_str = f", <b>PnL: {pnl_percent:+.2f}%</b>"

        return (
            f"{emoji} <b>EXIT {pos_type}</b> <code>{html_escape(symbol)}</code>\n"
            f"Exit Price: <code>${exit_price:,.4f}</code>{pnl_str}\n"
            f"Reason: <i>{reason}</i>"
        )

    # ---------------------------------------------------------------------
    # FORMATTER FOR NEW TRADE SIGNALS (more polished)
    # ---------------------------------------------------------------------

    # Accept multiple key names for side/type & price
    signal_type_raw = (signal.get("type") or signal.get("side") or "UNKNOWN").upper()
    # Map BUY/SELL to LONG/SHORT for readability
    signal_type_fmt = "LONG" if signal_type_raw == "BUY" else (
        "SHORT" if signal_type_raw == "SELL" else signal_type_raw)

    price = signal.get("entry_price") or signal.get("price") or 0.0
    tp    = signal.get("take_profit")
    sl    = signal.get("stop_loss")
    strategy = html_escape(signal.get("strategy", "N/A"))
    reason = html_escape(signal.get("reason", "No reason provided."))
    confidence = signal.get("confidence", 0.0)
    long_term_trend = "Bullish"  # TODO ‚Äì integrate real market trend

    # -----------------------------------------------------------------
    # Early exit for clearly malformed payloads (missing critical fields)
    # -----------------------------------------------------------------
    if signal_type_fmt == "UNKNOWN" and price == 0.0:
        # Returning None tells the caller to ignore this payload entirely.
        return None

    # Default unknown message (will rarely be used after the guard above)
    message = (f"‚ÑπÔ∏è <b>Unknown Signal</b> for <code>{html_escape(symbol)}</code> at <code>${price:,.2f}</code>")

    if signal_type_fmt in ("LONG", "SHORT"):
        direction_emoji = "üìà" if signal_type_fmt == "LONG" else "üìâ"
        
        # Calculate missing TP/SL fallbacks if needed
        if not tp:
            tp = price * (1 + (0.02 if signal_type_fmt == "LONG" else -0.02))
        if not sl:
            sl = price * (1 - (0.01 if signal_type_fmt == "LONG" else -0.01)) # Tighter default SL

        message = (
            f"{direction_emoji} <b>{signal_type_fmt} SIGNAL</b> for <code>{html_escape(symbol)}</code>\n\n"
            f"<b>Entry:</b> <code>${price:,.4f}</code>\n"
            f"<b>Take Profit:</b> <code>${tp:,.4f}</code>\n"
            f"<b>Stop Loss:</b> <code>${sl:,.4f}</code>\n\n"
            f"<i>Strategy: {strategy}</i>\n"
            f"<i>Trigger: {reason}</i>"
        )

    # Future: handle AVG_UP / AVG_DOWN etc.
    elif signal_type_raw.startswith("AVG_"):
        message = (
            f"‚öñÔ∏è <b>AVERAGE {signal_type_raw.split('_')[1]}</b> on <code>{html_escape(symbol)}</code> at <code>${price:,.4f}</code>"
        )

    return message


# The send_telegram_message function is now deprecated and removed.
# The new async_telegram_notifier service handles sending directly
# using a MessageQueue for superior performance and rate-limiting.

# Removed startup notification function